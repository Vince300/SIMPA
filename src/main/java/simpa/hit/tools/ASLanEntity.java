package simpa.hit.tools;

import java.util.Collections;
import java.util.List;
import java.util.TreeMap;

import simpa.hit.learner.efsm.LiConjecture;
import simpa.hit.automata.State;
import simpa.hit.automata.efsm.EFSMTransition;
import simpa.hit.automata.efsm.Parameter;
import simpa.hit.drivers.efsm.EFSMDriver.Types;

public class ASLanEntity {
	private String name;
	private TreeMap<String, String> arguments, symbols, gsymbols;
	private TreeMap<Types, String> mappingKITASLan;
	private String functions;

	public ASLanEntity(String name) {
		this.name = name;
		arguments = new TreeMap<String, String>();
		addArgument("Actor", "agent");
		addArgument("Other", "agent");
		symbols = new TreeMap<String, String>();
		addSymbol("State", "nat");
		gsymbols = new TreeMap<String, String>();
		mappingKITASLan = new TreeMap<Types, String>();
		mappingKITASLan.put(Types.STRING, "text");
		mappingKITASLan.put(Types.NUMERIC, "int");
		mappingKITASLan.put(Types.NOMINAL, "text");
		gsymbols.put("system", "agent");
	}

	public void addSymbol(String name, String type) {
		symbols.put(name, type);
	}

	public void addGlobalSymbol(String name, String type) {
		gsymbols.put(name, type);
	}

	public void addArgument(String name, String type) {
		arguments.put(name, type);
	}

	public String toString() {
		String ent = header();
		ent += "specification " + name.replace(" ", "_").toUpperCase() + "\n";
		ent += "channel_model CCM\n";
		ent += "\n";
		ent += "entity Environment {\n";
		ent += printGlobalSymbols();
		ent += "  entity " + name.replace(" ", "_").toUpperCase() + "("
				+ printArguments() + "){\n";
		ent += printSymbols();
		ent += "    body {\n";
		ent += "      State := 0;\n";
		ent += "      while (true){\n";
		ent += "        select {\n";
		ent += printFunctions();
		ent += "        }\n";
		ent += "      }\n";
		ent += "    }\n";
		ent += "  }\n";
		ent += "  body {\n";
		ent += "    new " + name.replace(" ", "_").toUpperCase() + "(system"
				+ printActors() + ");\n";
		ent += "    %% TO BE COMPLETED\n";
		ent += "  }\n";
		ent += "}\n";
		return ent;
	}

	private String printActors() {
		char agent = 'a';
		if (arguments.isEmpty())
			return "";
		else {
			String arg = "";
			for (int i = 0; i < arguments.size() - 1; i++) {
				arg += ", " + agent++;
			}
			return arg;
		}
	}

	private String header() {
		return "%%%%%%%%%% Generated by SIMPA %%%%%%%%%%\n\n";
	}

	private String printFunctions() {
		return functions;
	}

	private String printGlobalSymbols() {
		if (gsymbols.isEmpty())
			return "";
		else {
			char agent = 'a';
			for (int i = 0; i < arguments.size() - 1; i++) {
				gsymbols.put(String.valueOf(agent++), "agent");
			}

			String sym = "  symbols\n";
			for (String key : gsymbols.keySet()) {
				sym += "    " + key + " : " + gsymbols.get(key) + ";\n";
			}
			return sym + "\n";
		}
	}

	private String printSymbols() {
		if (symbols.isEmpty())
			return "";
		else {
			String sym = "    symbols\n";
			for (String key : symbols.keySet()) {
				sym += "      " + Utils.capitalize(key) + " : "
						+ symbols.get(key) + ";\n";
			}
			return sym + "\n";
		}
	}

	private String printArguments() {
		if (arguments.isEmpty())
			return "";
		else {
			String arg = "";
			for (String key : arguments.keySet()) {
				arg += key + " : " + arguments.get(key) + ", ";
			}
			return arg.substring(0, arg.length() - 2);
		}
	}

	public void loadFromEFSM(LiConjecture conjecture) {
		for (String sym : conjecture.gSymbols) {
			gsymbols.put(sym, "text");
		}
		functions = "";
		conjecture.cleanMark();
		for (int i = 0; i < conjecture.getStateCount(); i++) {
			functions += "          on(State = " + i + "): {\n";
			writeState(conjecture, conjecture.getState(i));
			functions += "          }\n";
		}
	}

	private void writeState(LiConjecture conjecture, State state) {
		functions += "            select {\n";
		for (String input : conjecture.getInputSymbols()) {
			List<EFSMTransition> currentTrans = conjecture
					.getTransitionFromWithInput(state, input, true);
			if (currentTrans.isEmpty()) {
				break;
			}

			List<String> paramNames = conjecture.getParamNames(currentTrans
					.get(0).getInput());
			functions += "              on(Other -> Actor: "
					+ currentTrans.get(0).getInput().toLowerCase() + "(";
			String param = "";
			if (!paramNames.isEmpty()) {
				functions += "?" + Utils.capitalize(paramNames.get(0));
				param += "text";
			}
			for (int i = 1; i < paramNames.size(); i++) {
				functions += ", ?" + Utils.capitalize(paramNames.get(i));
				param += ", text";
			}
			gsymbols.put(currentTrans.get(0).getInput().toLowerCase() + "("
					+ param + ")", "message");
			functions += ")): {\n";
			for (EFSMTransition t : currentTrans) {
				String space = "                ";
				if (!conjecture.getLabelForTransition(t).getPredicates()
						.isEmpty()) {
					space += "  ";
					functions += "                if (";
					List<String> predicates = conjecture
							.getLabelForTransition(t).getPredicates();
					Collections.sort(predicates);
					functions += Utils.joinAndClean(predicates, " | ");
					functions += "){\n";
				}

				for (Parameter p : conjecture.getLabelForTransition(t)
						.getInput().getParameters()) {
					symbols.put(p.value, mappingKITASLan.get(p.type));
				}

				for (String s : conjecture.getLabelForTransition(t)
						.getOutputFunctions()) {
					if (s.indexOf("=>") == -1) {
						String[] value = s.split(" = ");
						if (value[1].startsWith("\"Ndv")) {
							functions += space + value[0]
									+ " := fresh();\n";
						} else {
							try {
								float floatValue = Float.parseFloat(value[1]);
								functions += space
										+ value[0]
										+ " := "
										+ floatValue + ";\n";
							} catch (NumberFormatException e) {
								functions += space + value[0] + " := "
										+ value[1].trim() + ";\n";
								addGlobalSymbol(value[1].trim(), "text");
							}
						}
					} else {
						String[] value1 = s.split(" => ");
						String[] value2 = value1[1].split(" = ");
						functions += space + "if ("
								+ Utils.filter(value1[0]) + "){\n";
						functions += space + "  " + value2[0] + " := "
								+ value2[1] + ";\n";
						functions += space + "}\n";
					}
				}
				paramNames = conjecture.getParamNames(conjecture
						.getLabelForTransition(t).getOutput()
						.getOutputSymbol());
				functions += space
						+ "Actor -> Other: "
						+ conjecture.getLabelForTransition(t).getOutput()
						.getOutputSymbol().toLowerCase() + "(";
				param = "";
				if (!paramNames.isEmpty()) {
					functions += Utils.capitalize(paramNames.get(0));
					param += "text";
				}
				for (int i = 1; i < paramNames.size(); i++) {
					functions += ", " + Utils.capitalize(paramNames.get(i));
					param += ", text";
				}
				functions += ");\n";
				gsymbols.put(conjecture.getLabelForTransition(t)
						.getOutput().getOutputSymbol().toLowerCase()
						+ "(" + param + ")", "message");

				for (Parameter p : conjecture.getLabelForTransition(t)
						.getOutput().getParameters()) {
					symbols.put(p.value, mappingKITASLan.get(p.type));
				}

				if (!conjecture.getLabelForTransition(t).getPredicates()
						.isEmpty()) {
					functions += "                  State := "
							+ t.getTo().getId() + ";\n";
					functions += "                }\n";
				} else {
					functions += "                State := "
							+ t.getTo().getId() + ";\n";
				}
			}
			functions += "              }\n";
		}

		functions += "            }\n";
	}
}
